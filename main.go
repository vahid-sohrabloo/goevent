package main

import (
	"database/sql"
	"html/template"
	"log"
	"os"
	"strings"

	_ "github.com/fzerorubigd/goql"
	"github.com/fzerorubigd/goql/astdata"
	"github.com/ogier/pflag"
)

var (
	pkg = pflag.StringP("package", "p", "", "the package to query against")
)

//TemplateEvent contian data for each event function
type TemplateEvent struct {
	EventName     string
	Def           string
	ClassName     string
	ParamsDef     string
	ParamsCallDef string
}

//TempletaData is main template data
type TempletaData struct {
	PackageName string
	Imports     []string
	Events      []TemplateEvent
}

var fileTemplate = `package {{ .PackageName }}
//     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
import(
	"sort"{{  range .Imports }}
	"{{.}}"
	{{ end }}
)

{{ range .Events }}
func (parentEvent *{{ .ClassName }}) On{{ .EventName }}(fn {{ .Def }})  {
	parentEvent.{{ .EventName }}=append(parentEvent.{{ .EventName }},fn)
}

func (parentEvent *{{ .ClassName }}) Fire{{ .EventName }}({{.ParamsDef}})  {
	for _,event:= range parentEvent.List{{ .EventName }} {
		event({{ .ParamsCallDef }})
	}
}

{{ end }}

`

func getImportPackage(param astdata.Definition) string {
	paramStar, ok := param.(*astdata.StarType)
	if ok == true {
		param = paramStar.Target()
	}
	paramsSelector, ok := param.(*astdata.SelectorType)
	if ok == true {
		if paramsSelector.Ident() != paramsSelector.String() {
			return paramsSelector.String()[0 : len(paramsSelector.Ident())-2]
		}
	}
	return ""
}

func main() {

	pflag.Parse()

	con, err := sql.Open("goql", *pkg)
	if err != nil {
		log.Fatal(err)
	}
	defer con.Close()

	rows, err := con.Query("select name,pkg_name,def from types where exported")
	if err != nil {
		log.Fatal(err)
	}
	templateData := new(TempletaData)

	mayNeedImport := make(map[string]bool, 0)
	for rows.Next() {
		var (
			name    string
			pkgName string
			def     *astdata.StructType
		)
		rows.Scan(&name, &pkgName, &def)

		for _, f := range def.Fields() {

			templateData.PackageName = pkgName
			arrayData, ok := f.Definition().(*astdata.ArrayType)
			if ok == false {
				continue
			}
			event := TemplateEvent{
				ClassName: name,
				EventName: f.Name(),
				Def:       arrayData.ValueDefinition().String(),
			}

			funcData, ok := arrayData.ValueDefinition().(*astdata.FuncType)
			if ok == false {
				continue
			}

			paramsDefs := make([]string, len(funcData.Parameters()))
			paramsCallDefs := make([]string, len(funcData.Parameters()))
			for i, param := range funcData.Parameters() {
				importPackage := getImportPackage(param.Definition())
				if importPackage != "" {
					mayNeedImport[importPackage] = true
				}

				paramsDefs[i] = param.Name() + " " + param.Definition().String()
				paramsCallDefs[i] = param.Name()
			}
			event.ParamsDef = strings.Join(paramsDefs, ",")
			event.ParamsCallDef = strings.Join(paramsCallDefs, ",")
			templateData.Events = append(templateData.Events, event)
		}

		for _, imports := range def.Package().Imports() {
			if _, ok := mayNeedImport[imports.TargetPackage()]; ok == true {
				templateData.Imports = append(templateData.Imports, imports.Path())
			}

		}
	}

	tmpl, err := template.New("test").Parse(fileTemplate)
	if err != nil {
		panic(err)
	}
	tmpl.Execute(os.Stdout, templateData)

}
